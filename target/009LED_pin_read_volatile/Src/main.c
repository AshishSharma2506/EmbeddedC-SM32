/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


// video 149
// same as 143 but now it will also work with O2 optimization as it uses 'volatile'

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	// creating the pointer variables for LED (PD12)
	// all peripheral registers are of 32 bits so chose uint32_t
	uint32_t volatile *pClckCtrlreg   = (uint32_t*) 0x40023830;  //clock control register
	uint32_t volatile *pPortDModereg  = (uint32_t*) 0x40020C00;  //mode selection for PD12
	uint32_t volatile *pPortDOutreg   = (uint32_t*) 0x40020C14;

	uint32_t volatile *pPortAModereg  = (uint32_t*) 0x40020000;  //GPIOA mode selection register
	/* now we have to tell the compliler that the data pointed by this poiter
	 may change unexpectedly, so we will add 'volatile'
	 now compiler will not optimize any read/write operations on this pointer*/
	uint32_t volatile *pPortAInreg    = (uint32_t*) 0x40020010;  //GPIOA input data register


	//Enable the clock for GPIOD and GPIOA peripheral in AHB1ENR (SET the 3rd bit position)
	*pClckCtrlreg = *pClckCtrlreg | (1<<3); // for GPIOD clock enable
	*pClckCtrlreg |= (1<<0); // for GPIOA clock enable. ECB44(i)

	//configure the PD12(LED) as Output
	// a) CLEAR the 24th and 25th postion
	*pPortDModereg &=  ~(3<<24); // as binary value of 3 is 11 so we shift by 24
	// b) SET the 24th bit
	*pPortDModereg |= 1<<24;

	// configure PA0 as input mode (GPIOA mode register)
	*pPortAModereg &= ~(3<<0);

	//read status of Pin PA0 (GPIOA Input Data Register)
	uint8_t pinStatus = (uint8_t) *pPortAInreg & 0x1;
	/*pPortAInreg will give 32 bits of data but we are concerend with only 1 bit the 0th bit
	 * associated with PA0
	 */

	while(1)// super loop
	{
		//read status of Pin PA0 (GPIOA Input Data Register)
		uint8_t pinStatus = (uint8_t)(*pPortAInreg & 0x1);
		/*pPortAInreg will give 32 bits of data but we are concerend with only 1 bit the 0th bit
		 * associated with PA0
		 */
		// placing the check
		if(pinStatus)
			{
			// turn ON the LED
			// SET 12th bit of GPIOD output data resgiter to make PD12 HIGH
			*pPortDOutreg |= (1<<12);
			}
		else
			{
			//turn LED OFF
			// CLEAR the GPIOD output data register to make PD12 LOW
			*pPortDOutreg &= ~(1<<12);
			}
	}

}
